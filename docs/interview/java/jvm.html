<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java-JVM（9） | SugarCode Blog</title>
    <meta name="description" content="一门永不过时的编程语言——Java 。Java 编程语言占比：据官方数据统计，在全球编程语言工程师的数量上，Java 编程语言以 1000 万的程序员数量位居首位。而且很多软件的开发都离不开 Java 编程，因此其程序员的数量最多。而在以 Java 编程为核心的开发领域中，Java 程序员的需求量 10 年来一直居于首位！ 关注我，带你走进 Java 的世界！">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/assets/style.88CkzqVK.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.RxfOrBX6.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.BDbPXOhk.js">
    <link rel="modulepreload" href="/assets/chunks/framework.Ds6Eueu6.js">
    <link rel="modulepreload" href="/assets/docs_interview_java_jvm.md.CM-1rXJC.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-f4468d7a><!--[--><!--]--><!--[--><span tabindex="-1" data-v-e447c754></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-e447c754>Skip to content</a><!--]--><!----><header class="VPNav" data-v-f4468d7a data-v-cc9dd77b><div class="VPNavBar" data-v-cc9dd77b data-v-98ffb67c><div class="wrapper" data-v-98ffb67c><div class="container" data-v-98ffb67c><div class="title" data-v-98ffb67c><div class="VPNavBarTitle has-sidebar" data-v-98ffb67c data-v-4b503d9c><a class="title" href="/" data-v-4b503d9c><!--[--><!--]--><!--[--><img class="VPImage logo" src="/images/system/logo.jpg" alt data-v-f4527aeb><!--]--><span data-v-4b503d9c>SugarCode Blog</span><!--[--><!--]--></a></div></div><div class="content" data-v-98ffb67c><div class="content-body" data-v-98ffb67c><!--[--><!--]--><div class="VPNavBarSearch search" data-v-98ffb67c><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-98ffb67c data-v-ff561a0c><span id="main-nav-aria-label" class="visually-hidden" data-v-ff561a0c> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-ff561a0c data-v-562e3cbe><!--[--><span data-v-562e3cbe>主页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/docs/interview/readBefore.html" tabindex="0" data-v-ff561a0c data-v-562e3cbe><!--[--><span data-v-562e3cbe>面试题</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/docs/knowledge/readBefore.html" tabindex="0" data-v-ff561a0c data-v-562e3cbe><!--[--><span data-v-562e3cbe>干货分享</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/docs/case/readBefore.html" tabindex="0" data-v-ff561a0c data-v-562e3cbe><!--[--><span data-v-562e3cbe>案例展示</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/docs/aboutSite.html" tabindex="0" data-v-ff561a0c data-v-562e3cbe><!--[--><span data-v-562e3cbe>站点说明</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/docs/aboutMe.html" tabindex="0" data-v-ff561a0c data-v-562e3cbe><!--[--><span data-v-562e3cbe>关于站长</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-98ffb67c data-v-3e6de47a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3e6de47a data-v-4698b85c data-v-3726b66d><span class="check" data-v-3726b66d><span class="icon" data-v-3726b66d><!--[--><span class="vpi-sun sun" data-v-4698b85c></span><span class="vpi-moon moon" data-v-4698b85c></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-98ffb67c data-v-3e576fcb data-v-42baa202><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-42baa202 data-v-27dc7f6e><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-98ffb67c data-v-6e90f605 data-v-c07e882e><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-c07e882e><span class="vpi-more-horizontal icon" data-v-c07e882e></span></button><div class="menu" data-v-c07e882e><div class="VPMenu" data-v-c07e882e data-v-3d7ad723><!----><!--[--><!--[--><!----><div class="group" data-v-6e90f605><div class="item appearance" data-v-6e90f605><p class="label" data-v-6e90f605>Appearance</p><div class="appearance-action" data-v-6e90f605><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6e90f605 data-v-4698b85c data-v-3726b66d><span class="check" data-v-3726b66d><span class="icon" data-v-3726b66d><!--[--><span class="vpi-sun sun" data-v-4698b85c></span><span class="vpi-moon moon" data-v-4698b85c></span><!--]--></span></span></button></div></div></div><div class="group" data-v-6e90f605><div class="item social-links" data-v-6e90f605><div class="VPSocialLinks social-links-list" data-v-6e90f605 data-v-42baa202><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-42baa202 data-v-27dc7f6e><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-98ffb67c data-v-e8104da4><span class="container" data-v-e8104da4><span class="top" data-v-e8104da4></span><span class="middle" data-v-e8104da4></span><span class="bottom" data-v-e8104da4></span></span></button></div></div></div></div><div class="divider" data-v-98ffb67c><div class="divider-line" data-v-98ffb67c></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-f4468d7a data-v-f414f456><div class="container" data-v-f414f456><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-f414f456><span class="vpi-align-left menu-icon" data-v-f414f456></span><span class="menu-text" data-v-f414f456>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-f414f456 data-v-410b07a5><button data-v-410b07a5>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-f4468d7a data-v-d9d2e79b><div class="curtain" data-v-d9d2e79b></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-d9d2e79b><span class="visually-hidden" id="sidebar-aria-label" data-v-d9d2e79b> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-0f5b6f63><section class="VPSidebarItem level-0" data-v-0f5b6f63 data-v-77ed1583><!----><div class="items" data-v-77ed1583><!--[--><div class="VPSidebarItem level-1 is-link" data-v-77ed1583 data-v-77ed1583><div class="item" data-v-77ed1583><div class="indicator" data-v-77ed1583></div><a class="VPLink link link" href="/docs/interview/readBefore.html" data-v-77ed1583><!--[--><p class="text" data-v-77ed1583>写在前面</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-0f5b6f63><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-0f5b6f63 data-v-77ed1583><div class="item" role="button" tabindex="0" data-v-77ed1583><div class="indicator" data-v-77ed1583></div><h2 class="text" data-v-77ed1583>Java</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-77ed1583><span class="vpi-chevron-right caret-icon" data-v-77ed1583></span></div></div><div class="items" data-v-77ed1583><!--[--><div class="VPSidebarItem level-1 is-link" data-v-77ed1583 data-v-77ed1583><div class="item" data-v-77ed1583><div class="indicator" data-v-77ed1583></div><a class="VPLink link link" href="/docs/interview/java/base.html" data-v-77ed1583><!--[--><p class="text" data-v-77ed1583>Base 基础</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-77ed1583 data-v-77ed1583><div class="item" data-v-77ed1583><div class="indicator" data-v-77ed1583></div><a class="VPLink link link" href="/docs/interview/java/collect.html" data-v-77ed1583><!--[--><p class="text" data-v-77ed1583>Collect 集合</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-77ed1583 data-v-77ed1583><div class="item" data-v-77ed1583><div class="indicator" data-v-77ed1583></div><a class="VPLink link link" href="/docs/interview/java/design_pattern.html" data-v-77ed1583><!--[--><p class="text" data-v-77ed1583>Design Pattern 设计模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-77ed1583 data-v-77ed1583><div class="item" data-v-77ed1583><div class="indicator" data-v-77ed1583></div><a class="VPLink link link" href="/docs/interview/java/thread.html" data-v-77ed1583><!--[--><p class="text" data-v-77ed1583>Thread 线程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-77ed1583 data-v-77ed1583><div class="item" data-v-77ed1583><div class="indicator" data-v-77ed1583></div><a class="VPLink link link" href="/docs/interview/java/jvm.html" data-v-77ed1583><!--[--><p class="text" data-v-77ed1583>JVM</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-f4468d7a data-v-d45605be><div class="VPDoc has-sidebar has-aside" data-v-d45605be data-v-33eb8004><!--[--><!--]--><div class="container" data-v-33eb8004><div class="aside" data-v-33eb8004><div class="aside-curtain" data-v-33eb8004></div><div class="aside-container" data-v-33eb8004><div class="aside-content" data-v-33eb8004><div class="VPDocAside" data-v-33eb8004 data-v-9d4c520d><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-9d4c520d data-v-ce6f73d4><div class="content" data-v-ce6f73d4><div class="outline-marker" data-v-ce6f73d4></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-ce6f73d4>当前页导航</div><ul class="VPDocOutlineItem root" data-v-ce6f73d4 data-v-69b40bfa><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-9d4c520d></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-33eb8004><div class="content-container" data-v-33eb8004><!--[--><!--]--><main class="main" data-v-33eb8004><div style="position:relative;" class="vp-doc _docs_interview_java_jvm" data-v-33eb8004><div><h1 id="java-jvm-9" tabindex="-1">Java-JVM（9） <a class="header-anchor" href="#java-jvm-9" aria-label="Permalink to &quot;Java-JVM（9）&quot;">​</a></h1><h2 id="_1-请简单说说-jvm。2️⃣🫑" tabindex="-1">1. 请简单说说 JVM。2️⃣🫑 <a class="header-anchor" href="#_1-请简单说说-jvm。2️⃣🫑" aria-label="Permalink to &quot;1. 请简单说说 JVM。2️⃣🫑&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">考点</p><p>JVM (全称 Java Virtual Machine)，即 Java 虚拟机。Java 虚拟机是 Java 实现跨平台的核心。</p><p>当我们点击运行程序的时候，编译器会将我们的 <code>.java</code> 源码文件编译成字节码文件（<code>.class</code>），接下来，JVM 会对字节码进行解释，将他们翻译成对应平台的机器指令，并运行。</p><p>除去 Java，Groovy、Kotlin、Scala 等语言也可以在 JVM 中运行。</p></div><h2 id="_2-请说一下-jvm-的工作原理。3️⃣" tabindex="-1">2. 请说一下 JVM 的工作原理。3️⃣ <a class="header-anchor" href="#_2-请说一下-jvm-的工作原理。3️⃣" aria-label="Permalink to &quot;2. 请说一下 JVM 的工作原理。3️⃣&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">考点</p><ol><li><strong>类加载器</strong>：负责将Java类加载到JVM中，包括加载Java核心类库和用户自定义类‌。</li><li><strong>字节码执行引擎</strong>：将Java字节码转换为可执行的机器码，通常有两种方式：解释执行和即时编译‌。</li><li><strong>即时编译器</strong>：将频繁执行的字节码转换为本地机器码，以提高程序的执行效率‌。</li><li><strong>垃圾回收器</strong>：自动回收不再使用的对象内存，以避免内存泄露和程序崩溃‌。</li><li><strong>安全管理器</strong>：控制Java程序的访问权限，通过安全策略文件来规定程序可访问的资源和操作‌。</li></ol></div><h2 id="_3-请阐述一下类的生命周期。🔟🥜" tabindex="-1">3. 请阐述一下类的生命周期。🔟🥜 <a class="header-anchor" href="#_3-请阐述一下类的生命周期。🔟🥜" aria-label="Permalink to &quot;3. 请阐述一下类的生命周期。🔟🥜&quot;">​</a></h2><h3 id="装载阶段-loading" tabindex="-1"><strong>装载阶段（Loading）</strong> <a class="header-anchor" href="#装载阶段-loading" aria-label="Permalink to &quot;**装载阶段（Loading）**&quot;">​</a></h3><p>将 Java 类的字节码文件加载到机器内存中，并在内存中构建出 Java 类的原型——类模板对象。</p><div class="tip custom-block"><p class="custom-block-title">类模板对象</p><p>所谓类模板对象，其实就是 Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。</p></div><p>作用：使得 Java 能够更加灵活地处理不同类型的对象，提高了代码的可重用性和可扩展性。</p><p>Class 类的构造方法是私有的，只有 JVM 能创建。</p><div class="tip custom-block"><p class="custom-block-title">Class 实例的位置</p><p>在 Java 中，.class 文件加载到原空间(方法区)之后，会在堆内存中创建 java.lang.Class 对象，来封装类位于方法区的数据结构，而对象的引用则存储在栈（stack）内存中。栈内存用于保存局部变量和方法调用的上下文信息。对象的引用指向堆内存中实际存储对象数据的位置。</p></div><h3 id="链接阶段-linking" tabindex="-1"><strong>链接阶段（Linking）</strong> <a class="header-anchor" href="#链接阶段-linking" aria-label="Permalink to &quot;**链接阶段（Linking）**&quot;">​</a></h3><ul><li>验证(Verification)</li></ul><p>当类加载到系统中，就开始链接操作，验证阶段就是为了验证加载的字节码是否符合规范。</p><ul><li>准备(Preparation)</li></ul><p>为静态变量分配并设置变量初始值。</p><p>当然，只有显式赋值或在静态代码块中赋值的变量才会生成 <code>clinit</code> 方法并执行，没有的话是不执行的。而且优先会执行父类的 <code>clinit</code>，然后才会执行子类的 <code>clinit</code>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>在准备阶段，number 的值为 0，而不是 1。赋值为 1 的操作需要等到初始化阶段才被执行。</p><ul><li>解析(Resolution)</li></ul><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h3 id="初始化阶段-initialization" tabindex="-1"><strong>初始化阶段(Initialization)</strong> <a class="header-anchor" href="#初始化阶段-initialization" aria-label="Permalink to &quot;**初始化阶段(Initialization)**&quot;">​</a></h3><p>初始化阶段是 JVM 类加载过程中的最后一个阶段，也是类加载过程中最重要的一环。</p><p>首先，初始化阶段会执行类构造器 <code>clinit</code> 方法，该方法是编译器自动生成的，用于对类的静态变量进行初始化。这个方法会按照静态变量的声明顺序执行，并且在多线程环境下保证线程安全。</p><p>其次，初始化阶段会执行静态初始化块中的代码，静态初始化块是在类加载时执行的一段代码，它可以用于对静态变量进行复杂的初始化操作，或者执行一些其他需要在类加载时完成的任务。</p><p>需要注意的是，初始化阶段是按照初始化顺序依次执行的，并且只会执行一次。如果一个类已经被初始化过了，那么在后续的加载过程中不会再次执行初始化阶段，即使有多个类加载器加载了相同的类也是如此。</p><p>初始化阶段的目的是确保类的静态变量被正确初始化，并且执行一些必要的初始化操作，以使类可以正常使用。在程序运行过程中，如果需要访问某个类的静态变量或者静态方法，那么这个类必须经过初始化阶段，否则会抛出 <code>java.lang.ExceptionInInitializerError</code> 异常。</p><p>到了这一阶段，类加载过程才真正完成，我们可以安心地使用这个类了。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>只有当对类的主动使用的时候才会导致类的初始化。</p><p>主动使用有如下几种方式</p><ul><li>new 对象时</li><li>读取静态变量或给静态变量重新赋值</li><li>调用静态函数</li><li>反射调用</li><li>子类初始化</li><li>虚拟机启动的时候，要初始化主类。</li></ul><p>只有上述几种情况会触发初始化，也称为对一个类进行<code>主动引用</code>。</p><p>除此以外，有其他方式都不会触发初始化，称为<code>被动引用</code>。</p><p>eg：</p><ul><li>子类引用父类的静态变量，不会导致子类初始化。</li><li>通过数组定义引用类，不会触发此类的初始化。</li><li>引用常量时，不会触发该类的初始化。</li></ul><p>用 final 修饰某个类变量时，它的值在编译时就已经确定好放入常量池了，所以在访问该类变量时，等于直接从常量池中获取，并没有初始化该类。</p></div><h3 id="使用-using" tabindex="-1"><strong>使用(Using)</strong> <a class="header-anchor" href="#使用-using" aria-label="Permalink to &quot;**使用(Using)**&quot;">​</a></h3><p>程序代码执行时使用，new出对象程序中使用。</p><h3 id="类的卸载-unloading" tabindex="-1"><strong>类的卸载(Unloading)</strong> <a class="header-anchor" href="#类的卸载-unloading" aria-label="Permalink to &quot;**类的卸载(Unloading)**&quot;">​</a></h3><p>程序代码退出、异常、结束等，执行垃圾回收。</p><h2 id="_4-jvm-有那些核心组成-8️⃣🧅" tabindex="-1">4. JVM 有那些核心组成？8️⃣🧅 <a class="header-anchor" href="#_4-jvm-有那些核心组成-8️⃣🧅" aria-label="Permalink to &quot;4. JVM 有那些核心组成？8️⃣🧅&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">考点</p><ul><li><strong>类加载器</strong></li></ul><p>负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。</p><ul><li><strong>运行时数据区</strong></li></ul><p>JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括方法区、堆、栈、程序计数器和本地方法栈。</p><ul><li><strong>执行引擎</strong></li></ul><p>执行引擎是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器（JIT Compiler）和垃圾回收器（Garbage Collector）。</p></div><h2 id="_5-类加载器有那些-执行顺序是什么-9️⃣🧄" tabindex="-1">5. 类加载器有那些？执行顺序是什么？9️⃣🧄 <a class="header-anchor" href="#_5-类加载器有那些-执行顺序是什么-9️⃣🧄" aria-label="Permalink to &quot;5. 类加载器有那些？执行顺序是什么？9️⃣🧄&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">考点</p><p>Java 中有四种类加载器，他们的执行顺序是：启动类加载器 -&gt; 扩展类加载器 -&gt; 系统类加载器 -&gt; 自定义类加载器，详情如下：</p><ul><li>启动类加载器（Bootstrap ClassLoader）</li></ul><p>主要负责加载存放在 <code>JAVA_HOME/jre/lib</code> 下，或被 -Xbootclasspath 参数指定的路径下的，并且能被虚拟机识别的类库（如 rt.jar，所有的 java.* 开头的类均被 Bootstrap ClassLoader 加载），启动类加载器是无法被 Java 程序直接引用的。</p><ul><li>扩展类加载器（Extension ClassLoader）</li></ul><p>主要负责加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 <code>JAVA_HOME/jre/lib/ext</code> 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如 javax.* 开头的类），开发者可以直接使用扩展类加载器。</p><ul><li>系统类加载器（System ClassLoader）</li></ul><p>主要负责加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><ul><li>自定义类加载器（Custom ClassLoader）</li></ul><p>用户自定义的加载器。</p></div><h2 id="_6-什么是双亲委派模型-🔟🥦" tabindex="-1">6. 什么是双亲委派模型？🔟🥦 <a class="header-anchor" href="#_6-什么是双亲委派模型-🔟🥦" aria-label="Permalink to &quot;6. 什么是双亲委派模型？🔟🥦&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">考点</p><p>双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，如果没有加载过，再由顶向下进行加载。</p><p>每个 Java 实现的类加载器中保存了一个成员变量叫 <code>Parent</code> 类加载器。但是 <code>Parent</code> 加载器是和当前加载器是上下级关系，并不是继承关系。</p><p>在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。</p><p>之所以叫 <code>双亲委派模型</code> 其实就是翻译上的问题，Parent = 双亲。</p></div><div class="tip custom-block"><p class="custom-block-title">拓展</p><p>扩展类加载器（Extension Class Loader）负责加载位于 <code>JAVA_HOME/jre/lib/ext</code> 目录下的 jar 文件，这些文件通常是 Java 平台的扩展库。由于这些扩展库通常包含的是 Java 平台的基础功能，为了保证这些基础功能的稳定性和安全性，扩展类加载器被设计为没有父类。</p><p>启动类加载器（Bootstrap ClassLoader）是由 C++ 实现的，它是 jvm 中第一个被加载的类加载器。由于它是用 C++ 编写的，而不是 Java 语言，因此它没有父类。</p><p>此外，启动类加载器的设计使得它能够独立于 Java 类的继承结构，从而确保了JVM的核心功能的安全性和稳定性。由于它是最底层的类加载器，其他类加载器（如扩展类加载器和系统类加载器）都是通过委托机制来请求启动类加载器加载特定的类‌。</p></div><h2 id="_7-如果一个类重复出现在三个类加载器的加载位置-应该由谁来加载-3️⃣" tabindex="-1">7. 如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？3️⃣ <a class="header-anchor" href="#_7-如果一个类重复出现在三个类加载器的加载位置-应该由谁来加载-3️⃣" aria-label="Permalink to &quot;7. 如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？3️⃣&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">考点</p><p>启动类加载器加载，根据双亲委派机制，它的优先级是最高的。</p></div><div class="tip custom-block"><p class="custom-block-title">拓展</p><p>如果三个类加载器都都无法成功加载类会怎么样？</p><p>直接报异常：<code>ClassNotFountException</code>。</p></div><h2 id="_8-如何判断一个对象是否可被回收-8️⃣🥬" tabindex="-1">8. 如何判断一个对象是否可被回收？8️⃣🥬 <a class="header-anchor" href="#_8-如何判断一个对象是否可被回收-8️⃣🥬" aria-label="Permalink to &quot;8. 如何判断一个对象是否可被回收？8️⃣🥬&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">考点</p><h3 id="引用计数算法" tabindex="-1"><strong>引用计数算法</strong>： <a class="header-anchor" href="#引用计数算法" aria-label="Permalink to &quot;**引用计数算法**：&quot;">​</a></h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。</p><p>引用计数为 0 的对象可被回收。</p><p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><h3 id="可达性分析算法" tabindex="-1"><strong>可达性分析算法</strong>： <a class="header-anchor" href="#可达性分析算法" aria-label="Permalink to &quot;**可达性分析算法**：&quot;">​</a></h3><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p><p>Java 中 GC Roots 一般包含以下内容:</p><ol><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ol><h3 id="方法区的回收" tabindex="-1"><strong>方法区的回收</strong>： <a class="header-anchor" href="#方法区的回收" aria-label="Permalink to &quot;**方法区的回收**：&quot;">​</a></h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><h3 id="finalize" tabindex="-1"><strong>finalize</strong>： <a class="header-anchor" href="#finalize" aria-label="Permalink to &quot;**finalize**：&quot;">​</a></h3><p><code>finalize()</code> 类似 C++ 的析构函数，用来做关闭外部资源等工作，但是该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>我们可以使用 <code>try-finally</code> 等方式进行关闭外部资源，例如 IO 等。</p><p>当一个对象可被回收时，如果需要执行该对象的 <code>finalize()</code> 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 <code>finalize()</code> 方法自救，后面回收时不会调用 <code>finalize()</code> 方法。</p></div><h2 id="_9-java-中常见的垃圾回收算法有哪些-8️⃣🥒" tabindex="-1">9. Java 中常见的垃圾回收算法有哪些？8️⃣🥒 <a class="header-anchor" href="#_9-java-中常见的垃圾回收算法有哪些-8️⃣🥒" aria-label="Permalink to &quot;9. Java 中常见的垃圾回收算法有哪些？8️⃣🥒&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">考点</p><ul><li><strong>标记 清除</strong>：</li></ul><p>未回收内存分布图（红色：存活对象；绿色：可回收对象；白色：未使用）</p><table><tr><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:GREEN;"></td><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:GREEN;"></td><td style="background:WHITE;"></td><td style="background:GREEN;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:WHITE;"></td><td style="background:GREEN;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:GREEN;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td></tr></table><p>标记清除法会把存活对象进行标记，然后将可回收对象进行回收，回收之后内存分布图如下。</p><table><tr><td style="background:RED;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:WHITE;"></td></tr></table><p>缺点：</p><ol><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ol><ul><li><strong>标记 整理</strong>：</li></ul><p>未回收内存分布图（红色：存活对象；绿色：可回收对象；白色：未使用）</p><table><tr><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:GREEN;"></td><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:GREEN;"></td><td style="background:WHITE;"></td><td style="background:GREEN;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:WHITE;"></td><td style="background:GREEN;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:GREEN;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td></tr></table><p>标记整理法会将存活对象向一边移动，并且回收可回收对象，回收之后内存分布图如下。</p><table><tr><td style="background:RED;"></td><td style="background:RED;"></td><td style="background:RED;"></td><td style="background:RED;"></td><td style="background:RED;"></td><td style="background:RED;"></td></tr><tr><td style="background:RED;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr></table><ul><li><strong>复制</strong>：</li></ul><p>未回收内存分布图（红色：存活对象；绿色：可回收对象；白色：未使用；蓝色：保留区）</p><table><tr><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:GREEN;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td></tr><tr><td style="background:GREEN;"></td><td style="background:RED;"></td><td style="background:GREEN;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td></tr></table><p>首先，使用复制这种垃圾回收算法前，会将内存分为两部分（具体什么比例，可以自己定，也可以按照虚拟机默认来），每次使用只使用一部分。</p><p>好比说 A 部分内存用完了，就会将 A 的存活对象复制到 B，然后再把 A 的所有对象都清除，清楚后的内存分布图如下：</p><table><tr><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:RED;"></td><td style="background:RED;"></td><td style="background:RED;"></td></tr><tr><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:RED;"></td><td style="background:RED;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr><tr><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:BLUE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td><td style="background:WHITE;"></td></tr></table><p>缺点：</p><ol><li>我们总会存在有一块内存没有办法直接使用。</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ol><ul><li><strong>分代收集</strong>： 现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</li></ul><p>一般将堆分为新生代和老年代。</p><p>新生代使用: 复制算法。</p><p>老年代使用: “标记 清除” 或者 “标记 整理” 算法</p></div><div class="tip custom-block"><p class="custom-block-title">拓展</p><p>现在的商业虚拟机都采用 <code>复制</code> 这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 空间和其中一块 <code>Survivor</code>。在回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活着的对象一次性复制到另一块 <code>Survivor</code> 空间上，最后清理 <code>Eden</code> 和使用过的那一块 <code>Survivor</code>。</p><p>HotSpot 虚拟机的 <code>Eden</code> 和 <code>Survivor</code> 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 <code>Survivor</code> 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p></div></div></div></main><footer class="VPDocFooter" data-v-33eb8004 data-v-b67cf673><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-b67cf673><span class="visually-hidden" id="doc-footer-aria-label" data-v-b67cf673>Pager</span><div class="pager" data-v-b67cf673><a class="VPLink link pager-link prev" href="/docs/interview/java/thread.html" data-v-b67cf673><!--[--><span class="desc" data-v-b67cf673>上一页</span><span class="title" data-v-b67cf673>Thread 线程</span><!--]--></a></div><div class="pager" data-v-b67cf673><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-f4468d7a data-v-856d5f9e><div class="container" data-v-856d5f9e><!----><p class="copyright" data-v-856d5f9e>Copyright © 2024 suagecode.cn 版权所有</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"docs_aboutme.md\":\"C5sk1vBR\",\"docs_aboutsite.md\":\"Ct7dUBH7\",\"docs_case_kingpassword_readme.md\":\"KbsXLDlk\",\"docs_case_readbefore.md\":\"R2YDWbpw\",\"docs_interview_java_base.md\":\"BW20OE1N\",\"docs_interview_java_collect.md\":\"DtbHIYk6\",\"docs_interview_java_design_pattern.md\":\"iz8THij5\",\"docs_interview_java_jvm.md\":\"CM-1rXJC\",\"docs_interview_java_thread.md\":\"BmKf2NLv\",\"docs_interview_readbefore.md\":\"BkBnpuqd\",\"docs_knowledge_database_mysql_index_design_principles.md\":\"-7J9v40x\",\"docs_knowledge_database_mysql_index_principle.md\":\"Btf1kroF\",\"docs_knowledge_database_redis_test.md\":\"BIRuBbYa\",\"docs_knowledge_java_architecture_aot.md\":\"DK5Jlz75\",\"docs_knowledge_java_buildingblocks_captcha.md\":\"yS9KU6T-\",\"docs_knowledge_java_buildingblocks_expiringmap.md\":\"b1k89tF3\",\"docs_knowledge_java_buildingblocks_properties_secret.md\":\"DjbqEYEd\",\"docs_knowledge_java_buildingblocks_retry.md\":\"zrJ-SlFd\",\"docs_knowledge_java_class_callable_future_futuretask.md\":\"B1oc5d-_\",\"docs_knowledge_java_class_completefuture.md\":\"Dx6QNy3s\",\"docs_knowledge_java_class_executors.md\":\"QadGgqQd\",\"docs_knowledge_java_class_forkjoinpool.md\":\"BBun9-Ri\",\"docs_knowledge_java_keyword_synchronized.md\":\"BarXoDRG\",\"docs_knowledge_markdown_base.md\":\"DsUaTrIE\",\"docs_knowledge_markdown_emoji.md\":\"DjaEcBrf\",\"docs_knowledge_markdown_mermaid.md\":\"BHXIeT0X\",\"docs_knowledge_markdown_table.md\":\"Dau_jdf1\",\"docs_knowledge_markdown_vitepress.md\":\"ERlpUQo7\",\"docs_knowledge_readbefore.md\":\"BGj7bLPj\",\"index.md\":\"DcKQjPKX\",\"readme.md\":\"yjcnlMdM\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"SugarCode Blog\",\"description\":\"一门永不过时的编程语言——Java 。Java 编程语言占比：据官方数据统计，在全球编程语言工程师的数量上，Java 编程语言以 1000 万的程序员数量位居首位。而且很多软件的开发都离不开 Java 编程，因此其程序员的数量最多。而在以 Java 编程为核心的开发领域中，Java 程序员的需求量 10 年来一直居于首位！ 关注我，带你走进 Java 的世界！\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/images/system/logo.jpg\",\"nav\":[{\"text\":\"主页\",\"link\":\"/\"},{\"text\":\"面试题\",\"link\":\"/docs/interview/readBefore\"},{\"text\":\"干货分享\",\"link\":\"/docs/knowledge/readBefore\"},{\"text\":\"案例展示\",\"link\":\"/docs/case/readBefore\"},{\"text\":\"站点说明\",\"link\":\"/docs/aboutSite\"},{\"text\":\"关于站长\",\"link\":\"/docs/aboutMe\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}],\"sidebar\":{\"/docs/aboutSite\":[{\"text\":\"关于站点\",\"link\":\"/docs/aboutSite\"}],\"/docs/interview\":[{\"text\":\"写在前面\",\"link\":\"/docs/interview/readBefore\"},{\"text\":\"Java\",\"collapsed\":true,\"items\":[{\"text\":\"Base 基础\",\"link\":\"/docs/interview/java/base\"},{\"text\":\"Collect 集合\",\"link\":\"/docs/interview/java/collect\"},{\"text\":\"Design Pattern 设计模式\",\"link\":\"/docs/interview/java/design_pattern\"},{\"text\":\"Thread 线程\",\"link\":\"/docs/interview/java/thread\"},{\"text\":\"JVM\",\"link\":\"/docs/interview/java/jvm\"}]}],\"/docs/case\":[{\"text\":\"写在前面\",\"link\":\"/docs/case/readBefore\"},{\"text\":\"King Password\",\"link\":\"/docs/case/kingpassword/readme\"}],\"/docs/knowledge\":[{\"text\":\"写在前面\",\"link\":\"/docs/knowledge/readBefore\"},{\"text\":\"Java\",\"collapsed\":true,\"items\":[{\"text\":\"关键字\",\"collapsed\":true,\"items\":[{\"text\":\"synchronized\",\"link\":\"/docs/knowledge/java/keyword/synchronized\"}]},{\"text\":\"类\",\"collapsed\":true,\"items\":[{\"text\":\"Executors\",\"link\":\"/docs/knowledge/java/class/executors\"},{\"text\":\"Callable & Future & FutureTask\",\"link\":\"/docs/knowledge/java/class/callable_future_futureTask\"},{\"text\":\"CompleteFuture\",\"link\":\"/docs/knowledge/java/class/completeFuture\"},{\"text\":\"ForkJoinPool\",\"link\":\"/docs/knowledge/java/class/forkJoinPool\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"AOT\",\"link\":\"/docs/knowledge/java/architecture/aot\"}]},{\"text\":\"构建组件\",\"collapsed\":true,\"items\":[{\"text\":\"配置加密 - Properties Secret\",\"link\":\"/docs/knowledge/java/buildingBlocks/properties_secret\"},{\"text\":\"单体缓存 - ExpiringMap\",\"link\":\"/docs/knowledge/java/buildingBlocks/expiringMap\"},{\"text\":\"重试 - Retry\",\"link\":\"/docs/knowledge/java/buildingBlocks/retry\"},{\"text\":\"验证码 - captcha\",\"link\":\"/docs/knowledge/java/buildingBlocks/captcha\"}]}]},{\"text\":\"Markdown\",\"collapsed\":true,\"items\":[{\"text\":\"Base 基础\",\"link\":\"/docs/knowledge/markdown/base\"},{\"text\":\"Table 表格\",\"link\":\"/docs/knowledge/markdown/table\"},{\"text\":\"Mermaid 图表\",\"link\":\"/docs/knowledge/markdown/mermaid\"},{\"text\":\"Vitepress 内置扩展语法\",\"link\":\"/docs/knowledge/markdown/vitepress\"},{\"text\":\"Emoji 表情\",\"link\":\"/docs/knowledge/markdown/emoji\"}]},{\"text\":\"数据库\",\"collapsed\":true,\"items\":[{\"text\":\"MySQL\",\"collapsed\":true,\"items\":[{\"text\":\"索引原理\",\"link\":\"/docs/knowledge/database/mysql/index_principle\"},{\"text\":\"索引设计原则\",\"link\":\"/docs/knowledge/database/mysql/index_design_principles\"}]}]}]},\"outline\":{\"label\":\"当前页导航\",\"level\":[1,6]},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"footer\":{\"copyright\":\"Copyright © 2024 suagecode.cn 版权所有\"},\"search\":{\"provider\":\"local\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>