import{_ as e,c as i,o as s,ag as o}from"./chunks/framework.Ds6Eueu6.js";const k=JSON.parse('{"title":"MySQL 索引设计原则","description":"","frontmatter":{},"headers":[],"relativePath":"docs/knowledge/database/mysql/index_design_principles.md","filePath":"docs/knowledge/database/mysql/index_design_principles.md"}'),t={name:"docs/knowledge/database/mysql/index_design_principles.md"};function l(d,a,c,p,h,r){return s(),i("div",null,a[0]||(a[0]=[o('<h1 id="mysql-索引设计原则" tabindex="-1">MySQL 索引设计原则 <a class="header-anchor" href="#mysql-索引设计原则" aria-label="Permalink to &quot;MySQL 索引设计原则&quot;">​</a></h1><h2 id="什么情况下适合使用索引" tabindex="-1">什么情况下适合使用索引 <a class="header-anchor" href="#什么情况下适合使用索引" aria-label="Permalink to &quot;什么情况下适合使用索引&quot;">​</a></h2><h3 id="字段或字段组合存在唯一性" tabindex="-1">字段或字段组合存在唯一性 <a class="header-anchor" href="#字段或字段组合存在唯一性" aria-label="Permalink to &quot;字段或字段组合存在唯一性&quot;">​</a></h3><p>索引中有一种索引叫做：<code>主键索引</code>，这种索引是根据我们表的主键去创建的索引。</p><p>一个表中可以存在一个主键或者是多主键，也就是说通过 <code>主键</code> 我们可以找到唯一的值，像这样的字段去做索引是非常好的。</p><p>那除去这种 <code>主键</code> 字段，还有什么可以字段可以去做索引呢？</p><ul><li>学生表 - 学号</li><li>人员档案表 - 手机号、证件号</li><li>订单表 - 订单编号</li></ul><p>类似上面这些字段，我们可以创建 <code>唯一性索引</code>，一样可以加速我们的查找，提升性能。</p><h3 id="具有关联性的字段" tabindex="-1">具有关联性的字段 <a class="header-anchor" href="#具有关联性的字段" aria-label="Permalink to &quot;具有关联性的字段&quot;">​</a></h3><p>我们在写 SQL 语句的时候，经常会在 <code>WHERE</code> 或者 <code>关联查询</code> 中使用某些字段当做筛选条件或者是关联条件去做查询。</p><p>类似这样的字段我们可以去通过创建索引去提高查找速度。</p><div class="tip custom-block"><p class="custom-block-title">拓展</p><ul><li>如果进行 <code>UPDATE</code> 操作的时候，要更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</li><li><code>UPDATE</code> 时，<code>WHERE</code> 条件中的过滤条件列，如果使用到了索引，锁行；无法用索引，锁表。按照索引规则，如果能使用索引，锁行，不能使用索引，锁表。</li></ul></div><h3 id="经常使用-group-by-或者-order-by-的列" tabindex="-1">经常使用 GROUP BY 或者 ORDER BY 的列 <a class="header-anchor" href="#经常使用-group-by-或者-order-by-的列" aria-label="Permalink to &quot;经常使用 GROUP BY 或者 ORDER BY 的列&quot;">​</a></h3><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 <code>GROUP BY</code> 对数据进行分组查询，或者使用 <code>ORDER BY</code> 对数据进行排序的时候，就需要对分组或者排序的字段进行索引 。如果待排序的列有多 个，那么可以在这些列上建立组合索引 。</p><h3 id="distinct-字段" tabindex="-1">DISTINCT 字段 <a class="header-anchor" href="#distinct-字段" aria-label="Permalink to &quot;DISTINCT 字段&quot;">​</a></h3><p>有的时候，我们也会用到 <code>DISTINCT</code> 进行去重，我们也可以对这些字段进行创建索引。</p><p>原理就是索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>一般情况下，我们很少会对 <code>DISTINCT</code> 的字段进行创建索引~，所以这里各位了解即可。</p></div><h3 id="数据范围小的列" tabindex="-1">数据范围小的列 <a class="header-anchor" href="#数据范围小的列" aria-label="Permalink to &quot;数据范围小的列&quot;">​</a></h3><p>我们在创建表的时候，可以有多种数据类型去修饰我们的列类型，好比：<code>INT</code>、<code>VARCHAR</code>、<code>DATE</code>、<code>DECIMAL</code> 等等，但是，在这其中还有一些比较 <code>大</code> 的数据类型，类似：<code>BIGINT</code>、<code>TINYBLOB</code>、<code>TEXT</code>。</p><p>这些比较 <code>大</code> 的数据类型，它们的占用空间太大了，如果创建了索引，索引也是非常大的，所以说，这些字段是不推荐被创建索引的。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>我们在设计表的时候，尽量去多考虑我们的数据结构，如果能使用 <code>小</code> 的数据类型，就尽量使用小的数据类型。</p><p>数据类型越 <code>小</code>，被创建出来的索引也就越小，而且我们在查找的时候，一个数据页就可以放下更多的记录，这对查找数据是绝对有利的！！！</p></div><h3 id="数据类型占有比大的" tabindex="-1">数据类型占有比大的 <a class="header-anchor" href="#数据类型占有比大的" aria-label="Permalink to &quot;数据类型占有比大的&quot;">​</a></h3><p>我们对于某一个字段是否要创建索引，其中一个很重要的参考点是：这个列的数据是否类型很多！</p><p>好比像学生表，我们要对性别这一列进行创建索引，但是我们可以思考一下，性别无非几种：男、女、未填写。</p><p>也就是说这一列数据只有三种数据类型，如果我们根据性别去查询数据，那么 <code>MySQL</code> 是大概率不会走索引，而是走全表查询。</p><p>而我们要是对学生学号、手机号、证件号这种字段去创建索引，这个相对性别这种字段会好的多得多。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>联合索引中，尽量将“学号”、“手机号”、“证件号”放在索引的前面。</p><ul><li><p>错误示例：CREATE INDEX I_INDEX_001 ON student(sex);</p></li><li><p>错误示例：CREATE INDEX I_INDEX_001 ON student(createDt, deleteFlag, studentNo);</p></li><li><p>正确示例：CREATE INDEX I_INDEX_001 ON student(studentNo, createDt);</p></li></ul></div><h2 id="那些情况不适合使用索引" tabindex="-1">那些情况不适合使用索引 <a class="header-anchor" href="#那些情况不适合使用索引" aria-label="Permalink to &quot;那些情况不适合使用索引&quot;">​</a></h2><h3 id="where-条件中用不到的字段" tabindex="-1">WHERE 条件中用不到的字段 <a class="header-anchor" href="#where-条件中用不到的字段" aria-label="Permalink to &quot;WHERE 条件中用不到的字段&quot;">​</a></h3><p><code>WHERE</code> 后面跟的是筛选条件，如果说条件中不存在的字段，尽量不要去创建索引！</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>例如</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">no</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, age, birthday </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> student </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> no</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>我们现在要去创建索引，则只需要对 <code>no</code> 字段创建索引即可，可以不需要对其他列进行创建。</p></div><div class="tip custom-block"><p class="custom-block-title">拓展</p><p>但是！！！</p><p>要知道，索引除去它本身的作用，它也是可以提供一定量的数据。</p><p>有的时候我们经常将 SELECT 的列同 WHERE 中筛选条件的列一同创建联合索引，而 SELECT 的列之所以也一起创建到索引中，目的就是为了不读表，直接从索引中拿到数据。</p></div><h3 id="数据量少的表" tabindex="-1">数据量少的表 <a class="header-anchor" href="#数据量少的表" aria-label="Permalink to &quot;数据量少的表&quot;">​</a></h3><p>当你的表中全量数据很少的时候，这里是不建议去创建索引，直接全表查即可。</p><div class="tip custom-block"><p class="custom-block-title">拓展</p><p>但如果说表中数量少，但是经常使用的，例如 ORG 表，建议还是增加索引，毕竟直接从索引查询数据的速度远远比从磁盘扫描更快。</p></div><h3 id="数据类型占有比小的" tabindex="-1">数据类型占有比小的 <a class="header-anchor" href="#数据类型占有比小的" aria-label="Permalink to &quot;数据类型占有比小的&quot;">​</a></h3><p>和上面占有比大的相对，就好比性别这种列，完全没有必要去为它单独创建索引。</p><h2 id="创建索引的注意点" tabindex="-1">创建索引的注意点 <a class="header-anchor" href="#创建索引的注意点" aria-label="Permalink to &quot;创建索引的注意点&quot;">​</a></h2><h3 id="索引不要创建太多" tabindex="-1">索引不要创建太多 <a class="header-anchor" href="#索引不要创建太多" aria-label="Permalink to &quot;索引不要创建太多&quot;">​</a></h3><p>索引本身也是需要占用一定量的空间，所以尽可能的不要创建太多的索引，最好是可以让程序运行一段时间，然后归纳整理好需要的列，然后统一创建索引。</p><h3 id="尽量使用联合索引-多列索引" tabindex="-1">尽量使用联合索引（多列索引） <a class="header-anchor" href="#尽量使用联合索引-多列索引" aria-label="Permalink to &quot;尽量使用联合索引（多列索引）&quot;">​</a></h3><p>使用联合索引可以让我们在查询的时候优化器更好的规划我们SQL的执行，毕竟这会关系到我们 SQL 执行的速度。</p><h3 id="战略性索引" tabindex="-1">战略性索引 <a class="header-anchor" href="#战略性索引" aria-label="Permalink to &quot;战略性索引&quot;">​</a></h3><p>当我们表的数据量有很多，或者是经常被修改（添加、修改、删除）的表，尽量规划好索引，然后去创建，因为每次的修改操作，也会同步修改索引。</p><h3 id="不要定义重复索引" tabindex="-1">不要定义重复索引 <a class="header-anchor" href="#不要定义重复索引" aria-label="Permalink to &quot;不要定义重复索引&quot;">​</a></h3><p>我们在创建索引前，一定要去看我们的表中是否有类似的索引，如果有，就不要再去创建了。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>索引是一个双刃剑，用的好了，可以说是如虎添翼，用的不好，直接雪上加霜。</p><p>以上的所有文档是给你参考用的，实战中要灵活使用，不要太拘谨，程序是自由的。</p>',50)]))}const u=e(t,[["render",l]]);export{k as __pageData,u as default};
